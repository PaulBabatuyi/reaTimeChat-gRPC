Perfect â€” you're in **Germany** (CET), it's Monday afternoon, and you want a **laser-focused, scope-controlled, portfolio-killer** real-time chat API using **gRPC Go** that still impresses recruiters **without burning out**.

Hereâ€™s your **FINAL SIMPLIFIED PLAN** â€” directly inspired by *gRPC Go for Professionals* (chapters 1â€“9) but trimmed to what actually gets you hired in 2025.

### PROJECT NAME (for GitHub)
`grpc-chat-go` â€” simple, clear, professional.

### CORE PROMISE (README first line)
> A production-ready, real-time 1-on-1 chat API built with **gRPC bidirectional streaming**, **JWT auth**, **rate limiting**, and **TDD** â€” demoed with `grpcurl`.

### MINIMAL VIABLE FEATURES (MVP â€” 100% doable in 2â€“3 weeks)
| Feature | gRPC Type | Why it shines in interviews |
|--------|-----------|-----------------------------|
| `Register(email, password)` | Unary | Shows validation + password hash |
| `Login(email, password)` â†’ JWT | Unary | Stateless auth |
| `ChatStream()` | **Bidirectional streaming** | The star â€” real-time messages |
| `ListChats()` | Server streaming | Shows contact list with last message |
| `GetHistory(with_email)` | Server streaming | Paginated history |
| Built-in **AI Bot** (`bot@chat.example`) | Uses same `ChatStream` | Instant testing, no 2nd user needed |

Thatâ€™s it. No groups. No typing indicators. No gRPC-Web. No Godog. No Kubernetes.

### TECH STACK (exactly what you said + minimal glue)
```text
- google.golang.org/grpc
- Buf (for proto linting + generate)
- MongoDB (via official driver â€” NO GORM â€” keep it lightweight)
- Redis (only for rate limiting â€” `golang.org/x/time/rate` is enough, Redis optional later)
- github.com/golang-jwt/jwt
- golang.org/x/time/rate (rate limiting in interceptor)
- google/uuid (for message IDs)
- zerolog or log/slog (structured logs)
- testify (for tests)
- docker-compose (Mongo + Redis + API)
```

### BUSINESS LOGIC (what you will TDD â€” exact units)
```text
1. User Service
   - Register â†’ unique email, hashed password (bcrypt)
   - Login â†’ valid credentials â†’ JWT (24h exp, user_id in claims)
   - Auto-add bot@chat.example as contact on register

2. Chat Service
   - SendMessage(to_email, content)
     â†’ save to Mongo
     â†’ push to recipientâ€™s stream if online
     â†’ loopback to sender
   - Bot auto-reply: any message to bot â†’ "I'm a bot! You said: {content}" after 1.5s

3. Contact Service
   - ListChats â†’ distinct "other user" where messages exist, sorted by latest message timestamp
   - GetHistory â†’ messages between me and X, newest first, limit 50

4. Rate Limiting
   - 60 messages/min per user â†’ return gRPC `ResourceExhausted`
```

### gRPC SERVICE (.proto â€” copy-paste ready)
```proto
syntax = "proto3";

package chat.v1;
option go_package = "github.com/PaulBabatuyi/reaTimeChat-gRPC/proto/chat/v1";

import "google/protobuf/timestamp.proto";
import "google/protobuf/empty.proto";

service ChatService {
  rpc Register(RegisterRequest) returns (AuthResponse);
  rpc Login(LoginRequest) returns (AuthResponse);

  rpc ListChats(google.protobuf.Empty) returns (stream ChatSummary);
  rpc GetHistory(HistoryRequest) returns (stream Message);

  rpc ChatStream(stream ClientMessage) returns (stream ServerMessage);
}

message RegisterRequest { string email = 1; string password = 2; }
message LoginRequest { string email = 1; string password = 2; }
message AuthResponse { string token = 1; }

message ChatSummary {
  string email = 1;
  string last_message = 2;
  google.protobuf.Timestamp last_message_at = 3;
}

message HistoryRequest { string with_email = 1; }

message Message {
  string msg_id = 1;
  string from_email = 2;
  string to_email = 3;
  string content = 4;
  google.protobuf.Timestamp sent_at = 5;
}

message ClientMessage {
  string to_email = 1;
  string content = 2;
}

message ServerMessage {
  string msg_id = 1;
  string from_email = 2;
  string content = 3;
  google.protobuf.Timestamp sent_at = 4;
}
```

### INTERCEPTORS (Chapter 7 & 8 gold)
```go
1. UnaryInterceptor:  JWT validation
2. StreamInterceptor: JWT + rate limiting (x/time/rate)
3. Logging interceptor (method, duration, error)
```

### DESIGN PATTERN (clean, testable â€” recruiters love this)
```
internal/
â”œâ”€â”€ server/          // grpc server + interceptors
â”œâ”€â”€ service/         // business logic (ChatService, UserService)
â”œâ”€â”€ repository/      // mongo + redis interfaces
â”‚   â”œâ”€â”€ user_repo.go
â”‚   â”œâ”€â”€ message_repo.go
â”œâ”€â”€ model/           // domain types
â”œâ”€â”€ interceptor/     // auth, rate_limit, logging
â””â”€â”€ bot/             // bot handler
```

### TESTING STRATEGY (TDD focus â€” 90%+ coverage)
```text
unit/
  â”œâ”€â”€ user_service_test.go       (register duplicate, login fail)
  â”œâ”€â”€ chat_service_test.go       (send to self, to bot, to offline)
  â”œâ”€â”€ rate_limiter_test.go       (burst, refill, block after limit)
  â”œâ”€â”€ bot_test.go                (reply format, delay)

integration/
  â”œâ”€â”€ chat_integration_test.go   (start real server, two clients, exchange messages)
```

Use `testify/suite` + in-memory Mongo (or testify mock) + real Redis or in-memory rate limiter.

### DEMO SCRIPT (for README.md â€” copy-paste)
```bash
# 1. Start
docker-compose up -d

# 2. Register
grpcurl -plaintext -d '{"email":"alice@example.com","password":"secret"}' \
  localhost:50051 chat.v1.ChatService/Register

# 3. Login â†’ get token
TOKEN=$(grpcurl -plaintext -d '{"email":"alice@example.com","password":"secret"}' \
  localhost:50051 chat.v1.ChatService/Login | jq -r .token)

# 4. Open stream + send to bot
grpcurl -plaintext \
  -H "Authorization: Bearer $TOKEN" \
  -d '{"to_email":"bot@chat.example","content":"hello"}' \
  localhost:50051 chat.v1.ChatService/ChatStream
```

### FINAL DELIVERABLES (what gets you the job)
- GitHub repo with **perfect README** (screenshots of grpcurl working)
- `docker-compose.yml` (Mongo + Redis + API)
- `buf.yaml` + `buf.gen.yaml` (professional proto setup)
- 95% test coverage badge
- Live demo on **Railway.app** or **Fly.io** (free tier)
- One-paragraph in CV:  
  > â€œBuilt a real-time chat API with gRPC bidirectional streaming, JWT auth, and rate limiting. 100+ messages/sec, TDD, deployed on Fly.io.â€

### YOUR 2-WEEK PLAN (Germany time â€” realistic)
| Week | Goal |
|------|------|
| Monâ€“Tue | Proto + Buf + server skeleton + Register/Login (unary) |
| Wedâ€“Thu | JWT interceptor + ChatStream (loopback + save to Mongo) |
| Friâ€“Sat | Bot auto-reply + ListChats + GetHistory |
| Monâ€“Tue | Rate limiting interceptor + full tests |
| Wed    | docker-compose + grpcurl demo + README polish |
| Thu    | Deploy to Fly.io + record 2-min demo |

You now have **zero ambiguity**. This project directly uses **Chapters 4â€“9** of the book:
- Chapter 5 â†’ all RPC types
- Chapter 6 â†’ smart field design (timestamps, no unpacked)
- Chapter 7 â†’ interceptors, errors, metadata
- Chapter 8 â†’ rate limiting, auth
- Chapter 9 â†’ testing, debugging, Docker

Start now: `mkdir grpc-chat-go && cd grpc-chat-go && go mod init github.com/PaulBabatuyi/reaTimeChat-gRPC`

Want the **exact `buf.yaml` + `Dockerfile` + `docker-compose.yml`** next? Just say â€œgoâ€. Youâ€™re 100% ready. ğŸš€